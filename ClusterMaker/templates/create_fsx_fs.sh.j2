################################################################################
# Name:		create_fsx_fs.{{ cluster_name }}.sh
# Author:	Rodney Marable <rodney.marable@gmail.com>
# Created On:	April 20, 2019
# Last Changed:	May 9, 2019
# Deployed On:  {{ lookup('pipe','date \"+%B %-d, %Y\"') }}
# Purpose:	Create an FSx_Lustre file system for {{ cluster_name }}
################################################################################
#
#!/bin/sh

# Check for the presence of an existing Lustre file system associated with 
# this cluster.

fsx_fsid=$(aws --region {{ region }} fsx describe-file-systems | jq '.FileSystems[] | select( any (.Tags[]; .Key == "ClusterSerialNumber" and .Value == "{{ cluster_serial_number }}"))' | jq .DNSName | tr -d \")

# Create the Lustre file system if it doesn't already exist.
# Wait for it become availale before proceeding.

if [[ -z $fsx_fsid ]]
then
	fsx_fsid=`aws --region {{ region }} fsx create-file-system --file-system-type LUSTRE --storage-capacity {{ fsx_size }} --subnet-ids {{ subnet_id }} --tags Key=ClusterID,Value={{ cluster_name }} Key=ClusterSerialNumber,Value={{ cluster_serial_number }} Key=ClusterOwner,Value={{ cluster_owner }} Key=ClusterOwnerEmail,Value={{ cluster_owner_email }} Key=ClusterOwnerDepartment,Value={{ cluster_owner_department }}{% if 'UNDEFINED' not in project_id %} Key=ProjectID,Value={{ project_id }}{% endif %} Key=ProdLevel,Value={{ prod_level }} Key=DEPLOYMENT_DATE,Value=\"{{ DEPLOYMENT_DATE }}\" | grep FileSystemId | awk '{print $2}' | tr -d \" | tr -d ,`
	until [[ `aws --region {{ region }} fsx describe-file-systems --file-system-id ${fsx_fsid} | grep Lifecycle | awk '{print $2}' | tr -d '[:punct:]'` == "AVAILABLE" ]]
	do
		echo "Still waiting @ `date`..."
		sleep 15
	done
fi

# Parse the internal network interfaceId.

fsx_eni=`aws --region {{ region }} fsx describe-file-systems | jq '.FileSystems[] | select( any (.Tags[]; .Key == "ClusterSerialNumber" and .Value == "{{ cluster_serial_number }}"))' | jq -c .'NetworkInterfaceIds' | tr -d '[:punct:]' | sed -e "s/^eni/eni-/g"`

# Parse the EC2 security group.

fsx_eni_sg=`aws --region {{ region }} ec2 describe-security-groups --filters Name=group-name,Values=pcluster-{{ cluster_name }}-fsx  | jq '.SecurityGroups[].GroupId' | tr -d \"`

# Parse the DNS hostname.

fsx_dns_name=`aws --region {{ region }} fsx describe-file-systems | jq '.FileSystems[] | select( any (.Tags[]; .Key == "ClusterSerialNumber" and .Value == "{{ cluster_serial_number }}"))' | jq .DNSName | tr -d \"`

# Attach the Lustre security group to the internal interface.

aws --region {{ region }} ec2 modify-network-interface-attribute --network-interface-id ${fsx_eni} --groups ${fsx_eni_sg}

# PUT fsx_fsid_object and fsx_dns_name_object into s3_bucketname.
# Use these objects to mount {{ fsx_root }} on all cluster instances during
# the postinstall phase.

if [ ! -d {{ fsx_temp_dir }}
then
	mkdir {{ fsx_temp_dir }}
fi
echo $fsx_fsid > {{ fsx_temp_dir }}/{{ fsx_fsid_file }}
echo $fsx_dns_name > {{ fsx_temp_dir }}/{{ fsx_dns_name_file }}
aws --region {{ region }} s3 cp {{ fsx_temp_dir }}/{{ fsx_fsid_file }} {{ s3_object_path }}/{{ fsx_fsid_object }}
aws --region {{ region }} s3 cp {{ fsx_temp_dir }}/{{ fsx_dns_name_file }} {{ s3_object_path }}/{{ fsx_dns_name_object }}

exit 0
